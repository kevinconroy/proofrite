/* TAbiWord -- Ink support for AbiWord
* Copyright (C) 2003 Kevin Conroy
* 
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* as published by the Free Software Foundation; either version 2
* of the License, or (at your option) any later version.
* 
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
* 02111-1307, USA.
*/

#define WIN32_LEAN_AND_MEAN
#define NOWINABLE
#define NOMETAFILE
#define NOSERVICE
#define NOIME
#define NOMCX
#include <windows.h>

#include "gr_Win32Graphics.h"
#include "gr_Win32Image.h"
#include <xap_Win32App.h>

#include "ut_debugmsg.h"
#include "ut_assert.h"
#include "ut_string.h"
#include "ut_Win32OS.h"

#include "gr_Win32Stroke.h"

// describes the extended properties that we're using
#define STROKE_INKSPACE_POS_X L"{b6dca3e4-3f91-496b-b5bb-56d3e123cde3}"
#define STROKE_INKSPACE_POS_Y L"{a8f34806-d0d3-452d-afd2-dd2aceb48b65}"
#define STROKE_BASELINE_OFFSET_X L"{e160bf59-979b-4a56-8d69-82cb155a4919}"
#define STROKE_BASELINE_OFFSET_Y L"{c125e6d1-afc9-40d6-aa67-d1afb0b586ae}"
#define STROKE_GUID L"{b3cfe25c-8aaa-4c58-890f-664309e9d9cc}"




/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: ctor
* Purpose: Initalize the class with all of the appropriate variables
****************************************************************************/
GR_Win32Stroke::GR_Win32Stroke(IInkStrokeDisp *pIInkStrokeDisp) {
	UT_ASSERT(pIInkStrokeDisp);

	// save pointer to stroke
	this->m_pIInkStrokeDisp = pIInkStrokeDisp;
	this->_psa = NULL;

	// could be the case that this is a clone, in which case we don't
	// want to set the guid!!!!
	if(!this->hasGUID()) {
		// set the guid to the unique stroke id generated by the msft ink layer
		int id = this->_getId();

		this->setGUID(id);
	}
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: dtor
* Purpose: Clean up
****************************************************************************/
GR_Win32Stroke::~GR_Win32Stroke() {
	// clean up
	// this->m_pIInkStrokeDisp->Release();
	this->m_pIInkStrokeDisp = 0;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getInk
* Purpose: Get the Ink object which contains this stroke
****************************************************************************/
GR_Win32Ink * GR_Win32Stroke::getInk() {
	IInkDisp *ptrInk = 0;
	HRESULT hr = S_OK;

	// get the IInkDisp pointer
	hr = this->m_pIInkStrokeDisp->get_Ink(&ptrInk);
	UT_ASSERT(SUCCEEDED(hr));

	// wrap it in a GR_Win32Ink object (wrapper/adapter pattern)
	GR_Win32Ink *ptrWinInk = new GR_Win32Ink(ptrInk);

	return ptrWinInk;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getStartPoint
* Purpose: Returns the first point of the stroke
****************************************************************************/
InkPoint GR_Win32Stroke::getStartPoint() {
	// return value
	InkPoint point;

	// get the first point the array (that's the starting point)
	point = getNthPoint(0);

	return point;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getEndPoint
* Purpose: Returns the last point of the stroke
****************************************************************************/
InkPoint GR_Win32Stroke::getEndPoint() {
	// return value
	InkPoint point;

	// get number of points, minus 1 (that's the last one since zero based array)
	long lastPoint = this->getPointCount() - 1;

	// get the value
	point = getNthPoint(lastPoint);

	return point;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getNthPoint
* Purpose: Returns the Nth point in the stroke
****************************************************************************/
InkPoint GR_Win32Stroke::getNthPoint(long index) {	
	// value to return
	InkPoint nthPoint;
	HRESULT hr = S_OK;

	// total number of points
	long lPointCount = this->getPointCount();

	// make sure we're in bounds!
	UT_ASSERT(index < lPointCount);

	// get array of the points
	SAFEARRAY * psa = _getPointSafeArray();

	//UT_DEBUGMSG(("Size of the array: %d by %d.\n", psa->cDims, psa->rgsabound->cElements));

	// multiple by 2 since the array is actually: [x1, y1, x2, y2, x3, y3...]
	long i = index * 2;

	// get X
	hr = SafeArrayGetElement(psa, &i, &nthPoint.x);
	UT_ASSERT(SUCCEEDED(hr));

	++i;

	// get Y
	hr = SafeArrayGetElement(psa, &i, &nthPoint.y);
	UT_ASSERT(SUCCEEDED(hr));

	// debug
	//UT_DEBUGMSG(("Point %d of %d is %d, %d", (i/2)+1, lPointCount, nthPoint.x, nthPoint.y));
	//UT_DEBUGMSG((" or rather %d, %d\n", ((long*)(psa->pvData))[i-1], ((long*)(psa->pvData))[i]));

	return nthPoint;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _getPoints
* Purpose: Sets the passed in point to an array of InkPoints associated 
*		with the current stroke as well as the size of this array
****************************************************************************/
InkPoint* GR_Win32Stroke::_getPoints(long *numPoints) {
	*numPoints = getPointCount();

	// make a new array
	InkPoint *pts = new InkPoint[*numPoints];

	// get each point in the array
	for(int i = 0; i < (int)*numPoints; i++) {
		pts[i] = this->getNthPoint(i);
	}
	
	return pts;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _getPointSafeArray
* Purpose: Returns the SAFEARRAY of points associated with this stroke
****************************************************************************/
SAFEARRAY * GR_Win32Stroke::_getPointSafeArray() {
	// USE A LAZY LOADER FOR EFFICIENCY
	if(this->_psa == NULL) {
		// not loaded so load it!
		SAFEARRAY * psa = NULL;
		HRESULT hr = S_OK;

		// get a variant to hold the pointer to the array
		VARIANT vPoints;
		VariantInit(&vPoints);
		vPoints.vt = VT_ARRAY | VT_I4;

		// get a pointer to the safe array	
		hr = m_pIInkStrokeDisp->GetPoints(ISC_FirstElement, ISC_AllElements, &vPoints);
		UT_ASSERT(SUCCEEDED(hr));

		// convert the variant pointer to a SAFEARRAY pointer
		UT_ASSERT(vPoints.vt == (VT_ARRAY | VT_I4));
		psa = (vPoints.parray);

		this->_psa = psa;
	}
	else {
		// it was already loaded... just return the existing pointer
	}

	return this->_psa;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getPointCount
* Purpose: Returns the number of points contained in this stroke
****************************************************************************/
long GR_Win32Stroke::getPointCount() {
	long lPointCount = 0;	
	HRESULT hr = S_OK;		

	// query com object to see how many points are in this stroke
	hr = m_pIInkStrokeDisp->get_PacketCount(&lPointCount);
	UT_ASSERT(SUCCEEDED(hr));

	return lPointCount;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getId
* Purpose: Returns the Id of this stroke
****************************************************************************/
long GR_Win32Stroke::_getId() {
	long id = 0;	
	HRESULT hr = S_OK;

	// get the id of this stroke
	hr = this->m_pIInkStrokeDisp->get_ID(&id);
	UT_ASSERT(SUCCEEDED(hr));

	return id;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getScreenRectange
* Purpose: Returns the bounding box of this stroke according to the DrawingAttributes
*   (i.e. how it currently looks on the screen)
* Comments: Similar to the idea of the TabletPC's BoundingBox
****************************************************************************/
ScreenRect GR_Win32Stroke::getScreenRectange(GR_Win32InkOverlay *pInkOverlay, GR_Graphics *pG) {
	ScreenRect box(0,0,0,0);

	HRESULT hr = S_OK;

	IInkRectangle *pInkRectangle = 0;
	
	// make a new ink rectangle
	hr = CoCreateInstance(CLSID_InkRectangle, NULL, CLSCTX_INPROC_SERVER, 
		IID_IInkRectangle, 
		(void **) &pInkRectangle);
	UT_ASSERT(SUCCEEDED(hr));
  
	// get the bounding box
	hr = this->m_pIInkStrokeDisp->GetBoundingBox(IBBM_Default, &pInkRectangle);

	long top, left, bottom, right;
	pInkRectangle->get_Top(&top);
	pInkRectangle->get_Left(&left);
	pInkRectangle->get_Right(&right);
	pInkRectangle->get_Bottom(&bottom);

	InkPoint topLeftInk(left, top);
	InkPoint bottomRightInk(right, bottom);

	ScreenPoint topLeftScreen = pInkOverlay->convertToScreenPoint(pG, topLeftInk);
	ScreenPoint bottomRightScreen = pInkOverlay->convertToScreenPoint(pG, bottomRightInk);

	// set up values
	box.top = topLeftScreen.y - 5;
	box.left = topLeftScreen.x - 5;
	box.width = abs(bottomRightScreen.x - topLeftScreen.x) + 5;
	box.height = abs(bottomRightScreen.y - topLeftScreen.y) + 5;

	UT_ASSERT(SUCCEEDED(hr));

	return box;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getXmlId
* Purpose: Returns the Id of this stroke as a string in an Xml_Char *
****************************************************************************/
XML_Char * GR_Win32Stroke::getXmlId() {
	// return value
	XML_Char * strId = 0;

	// get the id
	int id = this->getGUID();

	// make a buffer that can store any value
	strId = new XML_Char[(sizeof(int)*8+1)];

	// convert the long to a string
	strId = (XML_Char *)itoa(id, strId, 10);

	return strId;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: draw
* Purpose: Draws the current stroke on the specified ink renderer and graphics object
****************************************************************************/
void GR_Win32Stroke::draw(GR_Graphics *pG, long HDC, IInkRenderer *pInkRenderer) {
	HRESULT hr = S_OK;

	GR_Win32Graphics *pGW = (GR_Win32Graphics *)pG;

	// draw the actual stroke
	hr = pInkRenderer->DrawStroke(HDC, this->m_pIInkStrokeDisp);
	UT_ASSERT(SUCCEEDED(hr));	

	// draws the bounding box around this ink stroke
#if DRAW_BOUNDING_BOX
	ScreenRect box = this->getScreenRectange(pGW->getInkOverlay(), pG);
	
	// get existing color
	UT_RGBColor prev;
	pG->getColor(prev);
	
	// blue
	pG->setColor(UT_RGBColor(0, 0, 255));

	// draw top line
	pG->drawLine(box.left, box.top, box.left + box.width, box.top);

	// draw left line
	pG->drawLine(box.left, box.top, box.left, box.top + box.height);

	// draw bottom line
	pG->drawLine(box.left, box.top + box.height, box.left + box.width, box.top + box.height);

	// draw right line
	pG->drawLine(box.left + box.width, box.top + box.height, box.left + box.width, box.top);

	// set prev color
	pG->setColor(prev);
#endif

#if DRAW_INSERTION_POINT
	InkPoint inkPoint = this->getInsertionPoint();
	ScreenPoint insertPoint = pGW->getInkOverlay()->convertToScreenPoint(pG, inkPoint);

	pG->fillRect(UT_RGBColor(128, 0, 255), insertPoint.x, insertPoint.y, 8, 8);
#endif
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: reflow
* Purpose: Apply all of the necessary transformations to the current Stroke to get it
*   to reflow in the document given the drawing arguments.
* Returns: true if the stroke reflowed and we need to redraw the old area in order
*     to get rid of the "ghost" stroke, false otherwise
****************************************************************************/
bool GR_Win32Stroke::reflow(dg_DrawArgs *pDA) {
	HRESULT hr = S_OK; 

	// return value
	bool value = false;

	// the position that we're drawing the stroke at (note that is position describes
	// a screen coordinate that falls on the baseline of the current Run that we're trying
	// to display NOT in the exact spot where the stroke is (although it is possible that it
	// could be if the stroke intersects the baseline of the run)
	ScreenPoint drawingScreenPosition(pDA->xoff, pDA->yoff);

	// get the current graphics object	
	GR_Graphics *pG = pDA->pG;
	GR_Win32Graphics *pGWin = (GR_Win32Graphics *)pG;
	GR_Win32InkOverlay *pInkOverlay = pGWin->getInkOverlay();
	HDC graphics = pGWin->getHDC();

	/*
	// see if we don't have a current position already
	if(!this->hasCurrentScreenPosition()) {
	// don't have a current screen position - assume the drawing position is it
	// (this occurs when a stroke is drawn for the first time)
	this->setCurrentScreenPosition(drawingScreenPosition);
	}

	// get the current screen position from the saved properties
	ScreenPoint currentScreenPositon = this->getCurrentScreenPosition();
	*/

	// debug
	UT_DEBUGMSG(("Drawing position = (%i, %i)\n", drawingScreenPosition.x,drawingScreenPosition.y));

	// see if we don't have a baseline offset
	if(!this->hasBaselineInkOffset()) {
		// convert to ink space so that we can get the right offset
		InkPoint currentInkPosition = this->getInsertionPoint(); // pInkOverlay->convertToInkPoint(pG, currentScreenPositon);
		InkPoint drawingInkPosition = pInkOverlay->convertToInkPoint(pG, drawingScreenPosition);

		// now that we have the current position and the new drawing position, calculate
		// the offset for movement
		InkPoint offset = this->_calculateOffset(currentInkPosition, drawingInkPosition);

		// don't have a baseline offset
		this->setBaselineInkOffset(offset);
	}

	// get the offset
	InkPoint baselineOffset = this->getBaselineInkOffset();

	// figure out where the stroke end (for real)
	InkPoint currentInkPosition = this->getInsertionPoint();
	// add the baseline offset so we're not small off by 10pt font errors
	currentInkPosition.x += baselineOffset.x;
	currentInkPosition.y += baselineOffset.y;

	// convert to ink space so that we can get the right offset	
	InkPoint drawingInkPosition = pInkOverlay->convertToInkPoint(pG, drawingScreenPosition);

	// now that we have the current position and the new drawing position, calculate
	// the offset for movement
	InkPoint offset = this->_calculateOffset(currentInkPosition, drawingInkPosition);

	// debug
	UT_DEBUGMSG(("Offset (in ink units) = (%i, %i)\n", offset.x,offset.y));

	// for efficiency, don't transform unless there is a non-zero offset (could be negative!)
	if(offset.x != 0 || offset.y != 0) {
		// now that we have the offset, let's create a transformation to use
		IInkTransform *pInkTransform;
		hr = CoCreateInstance(CLSID_InkTransform, NULL, CLSCTX_INPROC_SERVER, IID_IInkTransform, (void **) &pInkTransform);
		UT_ASSERT(SUCCEEDED(hr));

		// tell the transform where to move the ink to
		hr = pInkTransform->Translate((float)offset.x, (float)offset.y);
		UT_ASSERT(SUCCEEDED(hr));

		// now let's apply the transformation to the stroke!
		hr = this->m_pIInkStrokeDisp->Transform(pInkTransform, VARIANT_TRUE); 
		UT_ASSERT(SUCCEEDED(hr));

		// save the drawing position as the current position since the stroke has moved there
		// (then we'll get the right offset next time)
		this->setCurrentScreenPosition(drawingScreenPosition);

		// we reflowed, return true
		value = true;
	}

	return value;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _calculateOffset
* Purpose: Given the current position of the stroke (based on the saved extended
*   properties) and the current drawing position, we can calculate the offset required to move
****************************************************************************/
InkPoint GR_Win32Stroke::_calculateOffset(InkPoint currentInkPosition, InkPoint drawingInkPosition) {
	InkPoint offset;

	offset.x = drawingInkPosition.x - currentInkPosition.x;
	offset.y = drawingInkPosition.y - currentInkPosition.y;

	return offset;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getCurrentScreenPosition
* Purpose: Returns a ScreenPoint that denotes the current position; Reflects
*   the values in the extended properties of this stroke; ScreenPoint is (-1,-1)
*   if no values are saved in the extended properties.
****************************************************************************/
ScreenPoint	GR_Win32Stroke::getCurrentScreenPosition() {
	// return value
	ScreenPoint screenPoint(-1, -1);

	// make sure that we can get the properties first
	if(this->hasCurrentScreenPosition()) {
		// generate guids
		CComBSTR bstrGuidX(STROKE_INKSPACE_POS_X);
		CComBSTR bstrGuidY(STROKE_INKSPACE_POS_Y);

		// grab the location of the stroke
		VARIANT xScreen = this->_getExtendedProperty(bstrGuidX);
		VARIANT yScreen = this->_getExtendedProperty(bstrGuidY);

		// get the saved x position
		UT_ASSERT(xScreen.vt == VT_I4);
		screenPoint.x = (long)xScreen.lVal;

		// get the saved y position
		UT_ASSERT(xScreen.vt == VT_I4);
		screenPoint.y = (long)yScreen.lVal;	
	}

	return screenPoint;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: setCurrentScreenPosition
* Purpose: Sets the current screen position of this stroke (saves to extended properties)
****************************************************************************/
void	GR_Win32Stroke::setCurrentScreenPosition(ScreenPoint screenPoint) {
	// make variant to wrap the x coord
	VARIANT xPos;
	VariantInit(&xPos);
	xPos.vt = VT_I4;
	xPos.lVal = screenPoint.x;

	// make variant to wrap the y coord
	VARIANT yPos;
	VariantInit(&yPos);
	yPos.vt = VT_I4;
	yPos.lVal = screenPoint.y;

	// guids for the x and y coords
	CComBSTR bstrGuidX(STROKE_INKSPACE_POS_X);
	CComBSTR bstrGuidY(STROKE_INKSPACE_POS_Y);

	// save the current stroke location
	this->_setExtendedProperty(bstrGuidX, xPos);
	this->_setExtendedProperty(bstrGuidY, yPos);
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: hasCurrentScreenPosition
* Purpose: Determines if the stroke already has the extended properties needed
*   to denote its current screen position
****************************************************************************/
bool	GR_Win32Stroke::hasCurrentScreenPosition() {
	// return value
	bool hasPoint = true; // assume true so we can and it!

	// save the current ink location
	CComBSTR bstrGuidX(STROKE_INKSPACE_POS_X);
	CComBSTR bstrGuidY(STROKE_INKSPACE_POS_Y);

	// make sure it has the x and y coordinate!
	hasPoint = hasPoint && this->_hasExtendedProperty(bstrGuidX);
	hasPoint = hasPoint && this->_hasExtendedProperty(bstrGuidY);

	return hasPoint;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getGUID
* Purpose: Returns the int GUID for this stroke
****************************************************************************/
int	GR_Win32Stroke::getGUID() {
	// return value
	int id = -1;

	// make sure that we can get the properties first
	if(this->hasGUID()) {
		// generate guids
		CComBSTR bstrGuid(STROKE_GUID);

		// grab the location of the stroke
		VARIANT strokeGuid = this->_getExtendedProperty(bstrGuid);

		// get the saved x position
		UT_ASSERT(strokeGuid.vt == VT_I4);
		id = (long)strokeGuid.lVal;
	}

	return id;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: hasGUID
* Purpose: Determines if the stroke has a custom GUID assigned
****************************************************************************/
bool	GR_Win32Stroke::hasGUID() {
	// return value
	bool hasGUID = true; // assume true so we can and it!

	// get id for the extended prop
	CComBSTR bstrGuid(STROKE_GUID);

	// make sure it has the x and y coordinate!
	hasGUID = hasGUID && this->_hasExtendedProperty(STROKE_GUID);

	return hasGUID;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: setGUID
* Purpose: Sets the custom ID for this stroke
****************************************************************************/
void	GR_Win32Stroke::setGUID(int guid) {
	// make variant to wrap the guid
	VARIANT strokeGuid;
	VariantInit(&strokeGuid);
	strokeGuid.vt = VT_I4;
	strokeGuid.lVal = guid;

	// guids for the x and y coords
	CComBSTR bstrGuid(STROKE_GUID);

	// save the current stroke location
	this->_setExtendedProperty(bstrGuid, strokeGuid);
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _getExtendedProperty
* Purpose: Gets an extended property for the current stroke; returns VARIANT_FALSE
*   if the property does not exist
****************************************************************************/
VARIANT GR_Win32Stroke::_getExtendedProperty(CComBSTR guid) {
	// return value
	VARIANT value;
	HRESULT ret = S_OK;

	// get the extended properties collection
	IInkExtendedProperties *ptrExtendedProperties = 0;
	ret = this->m_pIInkStrokeDisp->get_ExtendedProperties(&ptrExtendedProperties);
	UT_ASSERT(SUCCEEDED(ret));

	IInkExtendedProperty *ptrExtendedProperty;

	if(this->_hasExtendedProperty(guid)) {
		// get it
		VARIANT key;
		VariantInit(&key);
		key.vt = VT_BSTR;
		key.bstrVal = guid;
		ret = ptrExtendedProperties->Item(key, &ptrExtendedProperty);
		UT_ASSERT(SUCCEEDED(ret));

		// get the value stored in the property
		ret = ptrExtendedProperty->get_Data(&value);
		UT_ASSERT(SUCCEEDED(ret));
	}
	else {
		// not here!!!
		VariantInit(&value);
		value.vt = VT_BOOL;
		value.boolVal = VARIANT_FALSE;
	}

	return value;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _setExtendedProperty
* Purpose: Sets an extended property for the current stroke 
****************************************************************************/
void	GR_Win32Stroke::_setExtendedProperty(CComBSTR guid, VARIANT value) {
	HRESULT ret = S_OK;

	// get the extended properties collection
	IInkExtendedProperties *ptrExtendedProperties = 0;
	ret = this->m_pIInkStrokeDisp->get_ExtendedProperties(&ptrExtendedProperties);
	UT_ASSERT(SUCCEEDED(ret));

	// pointer to property
	IInkExtendedProperty *ptrExtendedProperty = 0;

	// see if we already have a property with that name (means we need to update it)
	if(this->_hasExtendedProperty(guid)) {
		// get it
		VARIANT key;
		VariantInit(&key);
		key.vt = VT_BSTR;
		key.bstrVal = guid;
		ret = ptrExtendedProperties->Item(key, &ptrExtendedProperty);
		UT_ASSERT(SUCCEEDED(ret));

		// update it (should be reflected in memory)
		ret = ptrExtendedProperty->put_Data(value);
		UT_ASSERT(SUCCEEDED(ret));
	}
	// no such property - let's go ahead and add it!
	else {
		// need to add it
		ret = ptrExtendedProperties->Add(guid, value, &ptrExtendedProperty);
		UT_ASSERT(SUCCEEDED(ret));
	}

	// debug
	// UT_DEBUGMSG(("ptrExtendedProperty made using value[%i]\n", value.lVal));
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _hasExtendedProperty
* Purpose: Checks to see if a given extended property exists
****************************************************************************/
bool GR_Win32Stroke::_hasExtendedProperty(CComBSTR guid) {
	// return value
	bool hasExtendedProperty = false;

	HRESULT ret = S_OK;

	// get the extended properties collection
	IInkExtendedProperties *ptrExtendedProperties = 0;
	ret = this->m_pIInkStrokeDisp->get_ExtendedProperties(&ptrExtendedProperties);
	UT_ASSERT(SUCCEEDED(ret));

	// see if we already have this property; if so, update the value
	VARIANT_BOOL bolExists = VARIANT_FALSE;
	ret = ptrExtendedProperties->DoesPropertyExist(guid, &bolExists);
	UT_ASSERT(SUCCEEDED(ret));

	// if true, then change (should have been false on start)
	if(bolExists == VARIANT_TRUE) {
		hasExtendedProperty = true;
	}

	return hasExtendedProperty;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getBaselineInkOffset
* Purpose: Returns a the offset from the baseline in ink space; Reflects
*   the values in the extended properties of this stroke; InkPoint is (-1,-1)
*   if no values are saved in the extended properties.
****************************************************************************/
InkPoint	GR_Win32Stroke::getBaselineInkOffset() {
	// return value
	InkPoint inkPoint(-1, -1);

	// make sure that we can get the properties first
	if(this->hasBaselineInkOffset()) {
		// generate guids
		CComBSTR bstrGuidX(STROKE_BASELINE_OFFSET_X);
		CComBSTR bstrGuidY(STROKE_BASELINE_OFFSET_Y);

		// grab the location of the stroke
		VARIANT xScreen = this->_getExtendedProperty(bstrGuidX);
		VARIANT yScreen = this->_getExtendedProperty(bstrGuidY);

		// get the saved x position
		UT_ASSERT(xScreen.vt == VT_I4);
		inkPoint.x = (long)xScreen.lVal;

		// get the saved y position
		UT_ASSERT(xScreen.vt == VT_I4);
		inkPoint.y = (long)yScreen.lVal;	
	}

	return inkPoint;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: setBaselineInkOffset
* Purpose: Sets the baseline offset in ink (saves to extended properties)
****************************************************************************/
void	GR_Win32Stroke::setBaselineInkOffset(InkPoint inkPoint) {
	// make variant to wrap the x coord
	VARIANT xPos;
	VariantInit(&xPos);
	xPos.vt = VT_I4;
	xPos.lVal = inkPoint.x;

	// make variant to wrap the y coord
	VARIANT yPos;
	VariantInit(&yPos);
	yPos.vt = VT_I4;
	yPos.lVal = inkPoint.y;

	// guids for the x and y coords
	CComBSTR bstrGuidX(STROKE_BASELINE_OFFSET_X);
	CComBSTR bstrGuidY(STROKE_BASELINE_OFFSET_Y);

	// save the current stroke location
	this->_setExtendedProperty(bstrGuidX, xPos);
	this->_setExtendedProperty(bstrGuidY, yPos);
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: hasBaselineInkOffset
* Purpose: Determines if the stroke already has the extended properties needed
*   to denote its baseline offset
****************************************************************************/
bool	GR_Win32Stroke::hasBaselineInkOffset() {
	// return value
	bool hasPoint = true; // assume true so we can and it!

	// save the current ink location
	CComBSTR bstrGuidX(STROKE_BASELINE_OFFSET_X);
	CComBSTR bstrGuidY(STROKE_BASELINE_OFFSET_Y);

	// make sure it has the x and y coordinate!
	hasPoint = hasPoint && this->_hasExtendedProperty(bstrGuidX);
	hasPoint = hasPoint && this->_hasExtendedProperty(bstrGuidY);

	return hasPoint;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getInsertionPoint
* Purpose: Returns the point of the stroke that we'll use as the insertion
*   point for the stroke
****************************************************************************/
InkPoint GR_Win32Stroke::getInsertionPoint() {
	//return _getInsertionPoint_LastPoint();
	return _getInsertionPoint_LawOfCosines(WINDOW_SIZE);
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _getInsertionPoint_LastPoint
* Purpose: Returns the last point in the stroke and uses that as the insert
*   point for the stroke in the document
****************************************************************************/
InkPoint GR_Win32Stroke::_getInsertionPoint_LastPoint() {
	return getEndPoint();
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _getInsertionPoint_LawOfCosines
* Purpose: Uses the law of cosines to determine the best insertion point
*   Given points A, B, and C where the user draw line AB and line BC we can 
*   infer line AC and obtain a triangle. Since there is no guarantee about the 
*   type of triangle, we have to assume that it is an oblique triangle. Using the law 
*   of cosines and arccosine we can determine angle ABC (the angle at B formed by 
*   AB and BC).
* 
*   Rather than translating this angle into 0 to 360 space, wouldn't it be 
*   sufficient to simple calculate the angle ABC using a sliding window across 
*   the stroke data and taking the smallest angle that we find? The most acute 
*   angle would indicate that there was a very large change in direction from 
*   AB to BC irrespective of the orientation on the XY axis.
* 
*   Trying to find angle ABC (where u is).
* 
*           B
*          /u\
*         /   \
*        /     \
*       A       C
*  
*   The smallest angle in the stroke is the largest direction change!!!!!
****************************************************************************/
InkPoint GR_Win32Stroke::_getInsertionPoint_LawOfCosines(int window_size) {
	// make sure it's >=3
	UT_ASSERT(window_size >= 3);
	// make sure it's odd
	UT_ASSERT(window_size % 2 == 1);

	// the insertion point
	InkPoint insertionPoint(0,0);

	// get the points
	long numPoints = 0;
  InkPoint *pts = 0;
	
	// get an array of the points associated with this stroke
	pts = this->_getPoints(&numPoints);
	
	// should always have at least one point
	UT_ASSERT(numPoints > 0); // "Point array is empty!"

	// base case (a dot)
	if(numPoints == 1) {
		// only one point - that must be it!
		insertionPoint = pts[0];
	}
	else {
		// base case (a line with only start and end points)
		if(numPoints == 2) {
			// take the midpoint!
			insertionPoint =  _midpoint(pts[0], pts[1]);
		} 
		else { // numPoints > 2
			if(numPoints < window_size) {
				// larger window size than # points; let's decrease the window size
				// and run it on the stroke
				int smaller_window = numPoints;

				// make sure it's odd and smaller than the # points
				if(smaller_window % 2 == 0) {
					smaller_window--;
				}

				// call this function again with a window size that is just smaller than or equal
				// to the number of points in the current stroke
				insertionPoint = this->_getInsertionPoint_LawOfCosines(smaller_window);	
			}
			else {
				int numAngles = numPoints - window_size;
				// first, calculate the angle between all of the line segments formed
				double *angles = new double[numAngles];

				// for i = 0 to length - window size
				for(int i = 0; i < numPoints - window_size; i++) {
					// calculate the slope and add it to the list					
					angles[i] = _calculateAngle(pts[i], pts[i+(int)floor(window_size/2.)], pts[i + window_size]);
				}

				// now just find the minimum slope!				
				int indexOfMinAngle = 0;

				// now find the maximum difference
				for(int i = 1; i < numAngles; i++) {
					if(angles[i] < angles[indexOfMinAngle]) {
						// new minimum!
						indexOfMinAngle = i;
					}
				}

				// wanted the index, not the min angle because
				// we can translate from the index of the min angle
				// in the array back to the point B in the original array
				// of points to find the point B in smallest angle ABC
				insertionPoint = pts[indexOfMinAngle + (int)floor(window_size / 2.)];

				delete [] angles;
			}
		}
	}

	delete [] pts;

	//Trace.Assert(insertionPoint != Point.Empty, "Insertion point is empty!");
	UT_ASSERT(insertionPoint.x != 0);
	UT_ASSERT(insertionPoint.y != 0);

	return insertionPoint;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _midpoint
* Purpose: returns midpoint between two points
****************************************************************************/
InkPoint GR_Win32Stroke::_midpoint(InkPoint p1, InkPoint p2) 
{
	InkPoint mid(0,0);

	mid.x = (int)((p1.x + p2.x) / 2);
	mid.y = (int)((p1.y + p2.y) / 2);

	return mid;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _distance
* Purpose: calculate the length/distance of a line segment from the two end points
****************************************************************************/
double GR_Win32Stroke::_distance(InkPoint p1, InkPoint p2) 
{
	double hypothenus = 0;

	// make a right triangle out of them!!!
	double side1 = abs(p1.x - p2.x);
	double side2 = abs(p1.y - p2.y);

	// use sqrt(a^2 + b^2) = c
	hypothenus = sqrt(pow(side1, 2) + pow(side2, 2));

	return hypothenus;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: _calculateAngle
* Purpose: use law of cosines to determine the angle made by line segmenet 
*   AB and BC (acute angle between them) can infer line segment AC to make 
*   an opaque triangle
****************************************************************************/
double GR_Win32Stroke::_calculateAngle(InkPoint A, InkPoint B, InkPoint C) 
{
	double angle = 0;

	double numerator = pow(_distance(A, B), 2) + pow(_distance(B, C), 2) - pow(_distance(A, C), 2);
	double denominator = 2 * _distance(A, B) * _distance(B, C); 

	// make sure we don't divide by zero or try to do Acos with something not in 
	//   range -1 <= x <= 1 as either one will result in NaN when we really want
	//   to say that it's just so damn close to being a line that we'll just
	//   say that the angle is 180 degrees and be done with it
	if((int)denominator != 0 && abs((int)(numerator / denominator)) <= 1) 	{
		// calculate and convert to degrees from radians
		angle = (180 / PI) * acos(numerator / denominator);
	}
	else {
		// denom = 0... must be a straight line... say angle is 180!
		angle = 180;
	}

	UT_ASSERT(angle >= 0); //, "Angle not >= 0!");
	UT_ASSERT(angle <= 180); //, "Angle not <= 180!");
	
	return angle;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: clipStroke
* Purpose: Returns the portion of the stroke that insersects the specified 
*	rectangle/region
****************************************************************************/
GR_Win32Stroke * GR_Win32Stroke::clipStroke(GR_Graphics *pG, ScreenRect clippingRegion) {
	int delta = 10; // added to each side of the clipping region to account for buffer around stroke

	GR_Win32Graphics *pGR = ((GR_Win32Graphics *)pG);
	GR_Win32InkOverlay *overlay = pGR->getInkOverlay();
	GR_Win32Stroke *pStroke = 0;

	// convert top left
	ScreenPoint topLeft(clippingRegion.left - delta, clippingRegion.top - delta);
	InkPoint inkTopLeft = overlay->convertToInkPoint(pG, topLeft);
	
	// convert bottom right
	ScreenPoint bottomRight(clippingRegion.left + clippingRegion.width + delta, clippingRegion.top + clippingRegion.height + delta);
	InkPoint inkBottomRight = overlay->convertToInkPoint(pG, bottomRight);

	// make an ink rectangle out of it
	InkRect rect(inkTopLeft.x, inkTopLeft.y, inkBottomRight.y - inkTopLeft.y, inkBottomRight.x - inkTopLeft.x);

	if(rect.width > 0 && rect.height > 0) {
	    // pass it on to the real method
		pStroke = this->clipStroke(rect);
	}

	return pStroke;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: clipStroke
* Purpose: Returns the portion of the stroke that insersects the specified 
*	rectangle/region
****************************************************************************/
GR_Win32Stroke * GR_Win32Stroke::clipStroke(InkRect clippingRegion) {
	// return value
	GR_Win32Stroke *pClipping = this->clone();
	
	// to ensure that no errors occured
	HRESULT hr = S_OK;

	IInkRectangle *pInkRectangle = 0;
	
	// make a new ink rectangle
	hr = CoCreateInstance(CLSID_InkRectangle, NULL, CLSCTX_INPROC_SERVER, 
		IID_IInkRectangle, 
		(void **) &pInkRectangle);
	UT_ASSERT(SUCCEEDED(hr));

	// fill the rectangle
	hr = pInkRectangle->put_Left(clippingRegion.left);
	UT_ASSERT(SUCCEEDED(hr));

	hr = pInkRectangle->put_Top(clippingRegion.top);
	UT_ASSERT(SUCCEEDED(hr));

	hr = pInkRectangle->put_Bottom(clippingRegion.top + clippingRegion.height);
	UT_ASSERT(SUCCEEDED(hr));

	hr = pInkRectangle->put_Right(clippingRegion.left + clippingRegion.width);
	UT_ASSERT(SUCCEEDED(hr));

	// debug
	GR_Win32Ink *ink = this->getInk();
	UT_DEBUGMSG(("Prior to clipping: "));
	ink->print();

	int id = pClipping->getGUID();

	// clip the stroke to the rectangle
	hr = pClipping->m_pIInkStrokeDisp->Clip(pInkRectangle);
	UT_ASSERT(SUCCEEDED(hr));

	delete pClipping;
	pClipping = 0;

	// debug
	UT_DEBUGMSG(("After clipping: "));
	ink->print();

	pClipping = ink->getStroke(id);

	return pClipping;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: getDrawingAttributes
* Purpose: Gets associated drawing attributes
****************************************************************************/
IInkDrawingAttributes * GR_Win32Stroke::getDrawingAttributes() { 
	IInkDrawingAttributes *drawAttrs;

	HRESULT hr = S_OK;
	hr = this->m_pIInkStrokeDisp->get_DrawingAttributes(&drawAttrs);
	UT_ASSERT(SUCCEEDED(hr));

	return drawAttrs;
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: setDrawingAttributes
* Purpose: Sets associated drawing attributes
****************************************************************************/
void GR_Win32Stroke::setDrawingAttributes(IInkDrawingAttributes * drawAttrs) { 
	HRESULT hr = S_OK;
	hr = this->m_pIInkStrokeDisp->putref_DrawingAttributes(drawAttrs);
	UT_ASSERT(SUCCEEDED(hr));
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: clone
* Purpose: Creates a clone of the current stroke in the ink object
****************************************************************************/
GR_Win32Stroke * GR_Win32Stroke::clone() {
	GR_Win32Stroke * clone = 0;
	IInkDisp *pInkDisp = 0;
	IInkDrawingAttributes *drawAttrs = 0;

	HRESULT hr = S_OK;

	/*
	VARIANT var, varPK;
	VariantInit( &var );
	var.vt = VT_ARRAY | VT_I4;
	var.parray;
	//VariantInit( &varPK );
	*/
	
	long plCount = 0;
	hr = this->m_pIInkStrokeDisp->get_PacketCount(&plCount);
	UT_ASSERT(SUCCEEDED(hr));

	long plSize = 0;
	hr = this->m_pIInkStrokeDisp->get_PacketSize(&plSize);
	UT_ASSERT(SUCCEEDED(hr));

	long plArrayList = plSize * plCount;
	SAFEARRAY* pArray = ::SafeArrayCreateVector( VT_UI1, 0, plCount);
	if ( pArray == NULL ) return 0; // E_FAIL;

	CComVariant var;
	var.vt = VT_ARRAY | VT_UI1;
	var.parray = pArray;

	LPBYTE pArrayData = NULL;
	hr = ::SafeArrayAccessData(pArray,(void**) &pArrayData);
	UT_ASSERT(SUCCEEDED(hr));

	// default values of 0 and 1 return all packet data
	hr = this->m_pIInkStrokeDisp->GetPacketData(ISC_FirstElement, ISC_AllElements, &var);
	UT_ASSERT(SUCCEEDED(hr));

	drawAttrs = this->getDrawingAttributes();

	GR_Win32Ink *ink = this->getInk();

	// debug
	UT_DEBUGMSG(("Prior to clone: "));
	ink->print();

	// create a clone using the packet data
	// NOTE: varPK (packet description) is currently reserved, so it is
	// just empty variant for now.
	clone = ink->createStroke(var); //, varPK, &pInkDisp);
	clone->setDrawingAttributes(drawAttrs);

	hr = ::SafeArrayUnaccessData(pArray);
	UT_ASSERT(SUCCEEDED(hr));

	VariantClear( &var );

	// debug
	UT_DEBUGMSG(("After clone: "));
	ink->print();

	return clone;
}

/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: print
* Purpose: Helper debug function
****************************************************************************/
void GR_Win32Stroke::print() {
#if STROKE_DEBUG
	UT_DEBUGMSG(("Stroke: GUID[%d] InternalId[%d]\n", this->getGUID(), this->_getId()));
#endif
}


/***************************************************************************
* Author: Kevin M. Conroy (KMC)
* Function: removeFromScreen
* Purpose: Removes this stroke from the screen
****************************************************************************/
void GR_Win32Stroke::removeFromScreen() {
	// get the ink
	GR_Win32Ink *ink = this->getInk();

	// delete this stroke
	ink->deleteStroke(this->m_pIInkStrokeDisp);	
}

/**
 TO BE USED WITH LOGITECH CODE:

 	   VARIANT   var, varPK;
   LONG*   plongArray=NULL;
   POINT   ptArray[2]={0};
   long   lSize=0;
   IInkStrokeDisp* pInkStrokeDisp;

   IInkDisp*   pInk;   // the object should be created correctly
                       // elsewhere and assigned here.
   HRESULT   hr=E_FAIL;

   ptArray[0].x = 20;
   ptArray[0].y = 100;
   ptArray[1].x = 30;
   ptArray[1].y = 110;
   lSize = 2;   // two points

   VariantInit( &var );
   VariantInit( &varPK );
   SAFEARRAY* psa = SafeArrayCreateVector( VT_I4, 0, lSize*2 );
   if( psa )
   {
     if( SUCCEEDED( hr = SafeArrayAccessData( psa, (VOID**)&plongArray) ))
      {
         for( long i = 0; i < lSize; i++ )
         {
            plongArray[2*i] = ptArray[i].x;
            plongArray[2*i+1] = ptArray[i].y;
         }
         hr = SafeArrayUnaccessData( psa );

         if ( SUCCEEDED( hr ) )
         {
            var.vt     = VT_ARRAY | VT_I4;
            var.parray = psa;

           // varPK (packet description) is currently reserved, so it is
           // just empty variant for now.
            pInk->CreateStroke( var, varPK, &pInkStrokeDisp );   
         }
      }
   }
   VariantClear( &var );
   VariantClear( &varPK );

	 */